\subsection{Clock Synchronization Intervals and the Synchronization Procedure}
\label{subsec:intervals-and-sync-procedure}

As mentioned earlier, \timekeeper participants will periodically adjust their local clock.
%
We call the time interval between two adjustment points\footnote{The first interval in particular lies between the beginning of the execution and the first time parties adjust their clock.} a \emph{clock synchronization interval} (or ``interval'' for short).
%
Ideally, one interval will last for \syncLen rounds.
%
The actual number of local rounds that parties observe may differ according to the \shift computed in the previous interval (we will show later that the \shift computed in every interval is well-bounded).
%
When party \party's local clock gets to the last round of an interval, it will call \textsf{SyncProcedure} (\cref{protocol:sync-proc}) which adjusts its local clock and gets the fresh randomness to run the next interval.

\subsubsection{Interval Structure}
\label{subsubsec:interval-structure}

\timekeeper divides one interval into three phases: (i) \emph{view convergence}, (ii) \emph{beacon mining and inclusion}, and (iii) \emph{beacon-set convergence}.
%
The phase parties stay in depends on their local clocks.
%
Furthermore, parties will keep track of the (local) arriving time of a synchronization beacon as long as it is online.
%
In this section we describe these three phases as well as the bookkeeping function and explain the design intention behind them.

\paragraph{View convergence.}
%
When a party \party's local clock reports a time \protocolTime{\interval}{\round} such that $\round < (\interval - 1) \cdot \syncLen + \CPLen$, \party is in the \emph{view convergence} phase.
%
Note that this also includes rounds with potentially retorted timestamps.
%
In this phase, if \party is alert, it will try to mine the next block with the 2-for-1 PoW technique (i.e., the input information that \party forwards to the \funcRO functionality does not need to be changed); nonetheless, \party will not check if he successfully mines a beacon after \party acquires the output.
%
This is because all the beacons obtained in this phase are \emph{invalid} in that they report an undesirable timestamp.

The general motivation for introducing the view convergence phase and letting parties wait for some period of time at the beginning of an interval is that we would like parties to start mining beacons with a \emph{consistent} view of the previous interval.
%
Since \CPLen is larger than the common prefix parameter (we will quantify \CPLen later, in~\cref{subsec:protocl-params-conditions}), at the end of the view convergence phase of interval $\interval + 1$, alert parties will have a common view of interval \interval.
%
In other words, they will agree on all the blocks in interval \interval, and the adversary \adv will not be able to apply any changes to these blocks.
%
Hence, alert parties agree on the number of blocks in the previous interval, which decides the mining difficulty within the current interval.
%
(This will used in our new target recalculation function, presented in~\cref{subsec:target-recalculation-function}.)
%
Parties will mine beacons with the same difficulty, and this simplifies the protocol description as well as its analysis.
%
Furthermore, alert parties will compute the same fresh randomness as
%
\begin{equation} \label{eq:compute-freshness}
    \eta_{\interval + 1} \triangleq G(\eta_\interval \concat (\interval + 1) \concat v),
\end{equation}
%
where $v$ is the concatenation of all block hashes in interval \interval.
%
Note that we adopt a different hash function $G(\cdot)$ (as opposed to $H(\cdot)$) to compute the next fresh randomness that is not used in the 2-for-1 PoW , which does not consume any queries to random oracle \funcRO.

Recall that by assumption the adversary \adv has full knowledge of the network, and hence it can learn all honest blocks from the previous interval immediately and manipulate the chain at will for up to a number of rounds bounded by the common prefix parameter, allowing \adv to mine the synchronization beacons before the alert parties start to mine.
%
We call this period where \adv starts ahead of time the \emph{pre-mining} stage.
%
Nonetheless, we will show later that there will be at least one block generated by an alert party near the end of interval \interval, which prevents the adversary from pre-mining for too long a time.

\begin{remark} \label{remark:omit-view-convergence-phase}
    We note that, with some modifications, it is safe to get rid of the view convergence phase.
    %
    The fresh randomness will still need to be extracted from the settled part of the chain, so we will replace it with the randomness generated in previous beacon mining and inclusion phase.
    %
    This can be implemented by modifying some parameters but does not change the protocol framework.
    %
    The main difference lies in how validity of a timestamp beacon is checked.
    %
    At the beginning of a target recalculation epoch (which is also the beginning of an interval), parties may be mining on different chains, and hence mining beacons under different targets.
    %
    In order to check if the beacon target is correctly computed, some additional information (e.g., the block height of the previous target recalculation epoch) should be included in the block header (and the height should not be less than the number of blocks in the settled part).
    %
    Moreover, when parties run the synchronization procedure at the first interval in an epoch, they should use the ``weighted'' median timestamp instead of the plain median (and ``weighted'' means we would assign a weight to each timestamp based on its difficulty).
    %
    Details on applying the median timestamp are given in~\cref{subsubsec:sync-procedure}.
\end{remark}

\paragraph{Beacon mining and inclusion.}
%
When a party \party's local clock is in rounds \protocolTime{\interval}{\round} satisfying $(\interval - 1) \cdot \syncLen + \CPLen \le \round \le \interval \cdot \syncLen - \CPLen$, \party is in the \emph{beacon mining and inclusion} phase.
%
Next, we define the predicate \Isync{\interval} to extract the set of timestamps in this phase.
%
Formally,
%
\begin{equation} \label{eq:isync-def}
    \Isync{\interval} \triangleq \{(\interval - 1) \cdot \syncLen + \CPLen, \ldots, \interval \cdot R - \CPLen \}.
\end{equation}
%
For convenience, we slightly overload this predicate.
%
When the input is a timestamp, \Isync{\protocolTime{\interval}{\round}} outputs whether \protocolTime{\interval}{\round} stays in a beacon mining and inclusion phase.
%
I.e.,  $\Isync{\protocolTime{\interval}{\round}} = \true$ if $\round \in \Isync{\interval}$, and \false otherwise.

After entering this phase, \party will use a 2-for-1 PoW to mine both blocks and clock synchronization beacons.
%
During interval \interval, the output will be a beacon which indicates its local time and value $\beacon \triangleq \langle \protocolTime{\interval}{\round}, \party, ctr, blockLabel \rangle$.
%
Regarding the mining difficulty, \timekeeper will set the same target value for blocks and beacons.\footnote{We will adopt the same target for simplicity. Indeed, maintaining a constant ratio between the difficulty level of blocks and that of beacons will work.}
%
In other words, the expected number of blocks and of beacons in this phase are
equal.

After a beacon is successfully generated, it will be diffused into the network via $\funcDiffuse^{\mathsf{sync}}$.
%
\party will include a beacon \beacon into the pending block content if \beacon is valid w.r.t. the current interval.
%
Next, we describe how they check the validity of a beacon is checked.
%
The format of a beacon \beacon with respect to interval \interval is correct if and only if it reports a timestamp \protocolTime{\interval}{\round} such that $\round \in \Isync{\interval}$.
%
We say a beacon \beacon is \emph{valid w.r.t. chain \chain} if and only if its format is correct and the hash value of \beacon (after concatenating with the fresh randomness in \chain) is smaller than the corresponding mining target.
%
\party will try to include all the (valid) beacons mined in the current interval \interval with timestamps earlier than the current local time but which have not yet been included in the blockchain.
%
Specifically, at round \protocolTime{\interval}{\round}, all valid beacons recording timestamp \protocolTime{\interval}{u} with $u \le \round$ will get into \party's pending block content.

When \party's local clock goes past the last round of beacon mining and inclusion phase, it stops checking the beacon hash output and it no longer includes beacons in the next block. Beacons that are generated and diffused right at the end of this phase get dropped.

\paragraph{Beacon-set convergence.}
%
The third and last phase---\emph{beacon-set convergence}---consists of the last \CPLen rounds in an interval.
%
In other words, a party \party is in this phase when \party reports a timestamp
\protocolTime{\interval}{\round} with $\round > \interval \cdot \syncLen - \CPLen$.
%
During this phase, \party behaves similar to the first phase.
%
I.e., it will not check for the 2-for-1 PoW result to see if the beacon generation succeeds.

Parties have to wait for at least \CPLen rounds to ensure that they share a \emph{consistent} view of the set of beacons included in the current interval (except with some negligible probability).
%
This phase cannot be omitted (as opposed to the case of first phase mentioned in~\cref{remark:omit-view-convergence-phase}) since only when parties agree on the same beacon set can the synchronization procedure maintain the protocol's security properties (\cref{sec:protocol-analysis}).

\paragraph{Beacon arrival booking.}
%
In order to adjust its clock, \party also needs the local receiving time of all beacons that have been included in the chain.
%
Hence, \party will maintain a local registry that records the beacons it receives as well as their arrival time.
%
More specifically, this local beacon ledger is an array of synchronization beacons.
%
For each beacon \beacon, a pair $(a, \mathrm{flag}) \in \protocolTime{\mathbb{N}^+} {\mathbb{N}^+} \times \{\mathsf{final}, \mathsf{temp} \}$ is assigned to it.
%
Consider a round \protocolTime{\interval}{\round} when \party receives a beacon \beacon with $\timestamp{\beacon} = \protocolTime{\interval'}{\round'}$.
%
\begin{cccItemize}[noitemsep]
    \item If $\interval' \le \interval$, which means the beacon \beacon is generated in the current or previous interval.\footnote{Beacons generated in previous intervals are stale in that \party has already passed the synchronization point associated with these beacons, and they will never be used in the future. We list them for completeness.}
    %
    \party will drop \beacon if it is not valid w.r.t. its local chain; otherwise, \party will assign $(\protocolTime{\interval}{\round}, \mathsf{final})$ to \beacon.
    %
    This means that all the information gathering regarding this beacon has been finalized and it is ready to be used.

    \item If $\interval' > \interval$, the beacon is generated in the future.
    %
    \party will assign $(\protocolTime{\interval}{\round}, \allowbreak \mathsf{temp})$ to \beacon, which indicates that modifications on the receiving time may be applied in the future.
    %
    Note that parties may not know the fresh randomness in future intervals (for example, if they are newly joint parties and have not yet synchronized with the blockchain or they are alert but receive forthcoming beacons).
    %
    Hence they cannot check the validity of beacons with $\mathsf{temp}$ flag.
    %
    Nevertheless, invalid beacons would be excluded from the registry after \party learns the upcoming fresh randomness.
\end{cccItemize}
%
If \party receives multiple beacon messages with the same creator and time reported, \party will adopt the first one it receives as its arrival time.

\subsubsection{The Synchronization Procedure}
\label{subsubsec:sync-procedure}

At the end of an interval (i.e., when the local time reports $\round = \interval \cdot \syncLen$), parties will use the beacons information to compute a value \shift that indicates how much the logical clock should be adjusted.
%
(See~\cref{protocol:sync-proc} for the complete specification.)

\paragraph{Adjusting the local clock.}
%
When a party \party's local clock reaches round \protocolTime{\interval}{\interval \cdot \syncLen} and \party has finished the round's regular mining procedure, \party will adjust its local clock based on the beacons recorded on chain and their local receiving time.
%
More specifically, \party will extract all the beacons from the beacon mining and inclusion phase, and compute the differences between their timestamp and local receiving time $\timestamp{\beacon} - \mathsf{arrivalTime}(\beacon)$.
%
Since the timestamp of \beacon and its arrival time share the same interval index, we only need to compute the difference between their round numbers.
%
Subsequently, all the beacons will be ordered based on this difference and a \shift will be computed by selecting the median difference therein.
%
Formally,
%
\begin{equation} \label{eq:sync-shift}
    \shift^{\party}_\interval \triangleq \med \{ \timestamp{\beacon} - \mathsf{arrivalTime}(\beacon) \mathbin| \beacon \in \mathcal{S}^\party_\interval \}.
\end{equation}
%
In case there are two median beacons $\beacon_1, \beacon_2$, parties will adjust
$\shift^{\party}_\interval \triangleq \lceil (\timestamp{\beacon_1} - \mathsf{arrivalTime}(\beacon_1) + \timestamp{\beacon_2} - \mathsf{arrivalTime}(\beacon_2)) / 2 \rceil$.
%
Afterwards, \party will update its local clock to \protocolTime{\interval + 1}{\round + \shift}.
%
Later we show that this update strategy in the synchronization procedure allows parties' clocks to remain in a narrow interval and do not deviate too much from the nominal time.

Note that parties will enter local round \protocolTime{\interval}{\round} where $\round = \interval \cdot \syncLen$ only once.
%
If they enter some time \protocolTime{\interval'}{\round} in the future, we will get $\interval' > \interval$ and they will never revert back.

\paragraph{Mining with backward-set clocks.}
%
After the adjustment at the end of intervals, and \shift is added to \party's local clock, it may set its local time to values \protocolTime{\interval}{\round} such that $\round \le (\interval - 1) \cdot \syncLen$ (i.e., the retortion effect that was mentioned earlier).
%
Nonetheless, \party can continue to mine blocks with this timestamp and its local clock will eventually proceed to a time value of regular format (i.e., $\round > (\interval - 1) \cdot \syncLen$).

We compare this treatment with the similar scenario in a PoS blockchain \cite{EC:BGKRZ21}.
%
In~\cite{EC:BGKRZ21}, setting local clocks backward is never a problem since parties can keep silent during this period.
%
Due to the nature of PoS-based blockchains, parties do not need to do anything if they are not assigned the leader slot.
%
In our context, however, adopting the same `silence' policy contradicts the basic nature of PoW-based blockchains as parties will forfeit the chance to extend their local chain.
%
In other words, there is no point for an activate party to not make RO queries.
%
This is taken care of by \timekeeper's timestamping scheme.

\paragraph{Updating the beacon arrival time registry.}
%
Notice that the beacon information stored in a party \party's arrival time registry is closely related to which interval \party stays in; after \party enters the next interval, it needs to update the beacon bookkeeping.
%
\party will apply a shift computation for all beacons with flag $\mathsf{temp}$.
%
Furthermore, for those beacons that report a timestamp with interval equal to the incoming one, their flag will be set to $\mathsf{final}$.
%
In more detail, at the end of interval \interval, for all eligible \beacon in the beacon registry, their associated pair $(\protocolTime{\interval_\beacon}{\round_\beacon}, \mathsf{temp})$ will be updated to $(\protocolTime{\interval_\beacon}{\round_\beacon + \shift}, \mathsf{final})$ if $\interval_\beacon = \interval + 1$.
%
Note that for those beacons whose flags are set to $\mathsf{final}$, \party will remove all invalid ones from the registry after the update.
